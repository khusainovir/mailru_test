# Тестовое задание для Tarantool@Mail.ru

## Задание:
Создать доступное по HTTP KV-хранилище, используя Cartridge.
Для хранилища реализовать cktle.o

API:
 - POST /kv body: {key: "test", "value": {SOME ARBITRARY JSON}} 
 - PUT kv/{id} body: {"value": {SOME ARBITRARY JSON}}
 - GET kv/{id} 
 - DELETE kv/{id}

 - POST  возвращает 409 если ключ уже существует, 
 - POST, PUT возвращают 400 если боди некорректное
 - PUT, GET, DELETE возвращает 404 если такого ключа нет
 - все операции логируются
 - в случае, если число запросов в секунду в http api превышает заданый интервал, возвращать 429 ошибку

 ## Основа решения
 Основная часть решения состоит из 2 модулей:
 * role kv-router - часть, занимающаяся роутингом и валидацией запросов. При запуске перехватывает instance Tarantool.http и добавляет свои правила для роутинга.

* kv-storage - простое хранилище на Tarantool. В нем реализованы все нужные CRUD-операции.

## Дополнительные замечания
* Для удобного тестирования была создана дополнительная роль - ui-test.
По сути это примитивнейший статический http-сервер, выдающий контент.
Также была сделана простенькая HTML-форма для наглядной демонстрации API хранилища.
Доступна она по адресу %URI%/ui-test/index.html

* Я не нашел встроенных в http или Cartridge средств по ограничению количества запросов, поэтому реализовал свой вариант в достаточно простом виде.

* Логичнее всего для лимитирования и логирования запросов использовать middleware (http:use). Однако, если я понял правильно, в текущей версии Cartridge используется старая версия модуля http v1.1, в которой middleware отсутствует.

* Встроенные в Lua функции дают возможность получить время с точностью до секунды, поэтому для лимитирования запросов я использовал встроенные в Tarantool функции.

* Хоть у Tarantool есть свой модуль логирования, для большей гибкости я завел некий "интерфейсный" модуль. Впрочем, в данной реализации он использует tarantool.log.

* Я захардкодил максимальное количество запросов в секунду. По идее, лучше всего передавать его через конфигурацию, но для тестового задания решил просто сэкономить время, отметив, что правильный подход здесь я знаю.

* К заданию я добавил интеграционные тесты для API
